import{_ as s,p as i,q as l,R as e,t,a1 as o}from"./framework-8fa3e4ce.js";const r={},h=e("h1",{id:"githubflow",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#githubflow","aria-hidden":"true"},"#"),t(" GithubFlow")],-1),n=e("p",null,'Github flow 是Git flow的简化版，专门配合"持续发布"。它是 Github.com 使用的工作流程。',-1),c=e("h2",{id:"流程",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#流程","aria-hidden":"true"},"#"),t(" 流程")],-1),d=e("p",null,"它只有一个长期分支，就是master，因此用起来非常简单。",-1),u=e("p",null,"官方推荐的流程如下。",-1),p=["src"],_=o('<ol><li><p>根据需求，从master拉出新分支，不区分功能分支或补丁分支。</p></li><li><p>新分支开发完成后，或者需要讨论的时候，就向master发起一个pull request（简称PR）。</p></li><li><p>Pull Request既是一个通知，让别人注意到你的请求，又是一种对话机制，大家一起评审和讨论你的代码。对话过程中，你还可以不断提交代码。</p></li><li><p>你的Pull Request被接受，合并进master，重新部署后，原来你拉出来的那个分支就被删除。（先部署再合并也可。）</p></li></ol><h2 id="评价" tabindex="-1"><a class="header-anchor" href="#评价" aria-hidden="true">#</a> 评价</h2><p>Github flow 的最大优点就是简单，对于&quot;持续发布&quot;的产品，可以说是最合适的流程。</p><p>问题在于它的假设：master分支的更新与产品的发布是一致的。也就是说，master分支的最新代码，默认就是当前的线上代码。</p><p>可是，有些时候并非如此，代码合并进入master分支，并不代表它就能立刻发布。比如，苹果商店的APP提交审核以后，等一段时间才能上架。这时，如果还有新的代码提交，master分支就会与刚发布的版本不一致。另一个例子是，有些公司有发布窗口，只有指定时间才能发布，这也会导致线上版本落后于master分支。</p><p>上面这种情况，只有master一个主分支就不够用了。通常，你不得不在master分支以外，另外新建一个production分支跟踪线上版本。</p>',6);function m(a,f){return i(),l("div",null,[h,n,c,d,u,e("img",{src:a.$withBase("/image/dev/git/githubFlow.png"),alt:"示例"},null,8,p),_])}const w=s(r,[["render",m],["__file","GithubFlow.html.vue"]]);export{w as default};
