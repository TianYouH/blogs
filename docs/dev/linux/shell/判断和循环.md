# 判断和循环

## 条件测试

- 为命令的执行提供最直接的识别依据
  - 文件或目录的读/写等状态
  - 数值的大小
  - 字符串是否匹配
  - 多条件组合

### test测试操作

- 语法格式
  - `test 选项 参数`
  - [ 选项 参数 ]

> `help test` 查阅帮助

#### 字符串比较

- 基本语法
  - 是否为空`[ -z 字符串 ]`
  - 等于`[ 字符串1 == 字符串2 ]`
  - 不等于`[ 字符串1 !== 字符串2 ]`

```bash
[ -z $a ]
echo $? # 0
a=123
[ -z $a ]
echo $? # 1
```

#### 整数值比较

- `[ 整数值1 操作符 整数值2 ]`

|操作符|含义|
|:-:|:-:|
|-eq|等于（Equal）|
|-ne|不等于（Not Equal）|
|-ge|大于或等于（Greater or Equal）|
|-le|小于或等于（Less or Equal）|
|-gt|大于（Greater Equal）|
|-lt|小于（Less Equal）|

```bash
[ 3 -eq 3 ]
echo $? # 0
ls | wc -l # 10 返回文件个数
[ $(ls | wc -l) -le 5 ]
echo $? # 1
```

#### 文件状态测试

- `[ 操作符 文件或目录 ]`

|操作符|含义|
|:-:|:-:|
|-e|判断对象是否存在（Exist）,若存在则结果为真|
|-d|判断对象是否为目录（Directory）,是则为真|
|-f|判断对象是否为一般文件（File）,是则为真|
|-r|判断对象是有可读（Read）权限,是则为真|
|-w|判断对象是有可写（Write）权限,是则为真|
|-x|对象是否有可执行（eXcute）权限,是则为真|

```bash
[ -e /etc ]
echo $? # 0
[ -f /etc ]
echo $? # 1
```

### 组合多个命令

- 使用控制符组合多个命令
  - `;`  分割执行命令
  - `&&` 并且，在前置命令执行成功后才能之后后置命令
  - `||` 或者，优先执行前置命令，前置命令执行失败后执行后置命令

```bash
cd usr/ ; ls
# bin/  etc/  lib/  libexec/  share/  ssl/
cd usr/ && ls
# bin/  etc/  lib/  libexec/  share/  ssl/
cd usr错误目录/ || echo message
# message
```

### 多条件判断

- 使用&&、||进行多个条件的判断
  - `[ 判断1 ] && [ 判断2 ]`
  - `[ 判断1 ] || [ 判断2 ]`

## 示例

### 监控脚本

```bash
#!/bin/bash
# 获取系统各项性能参数指数，并与预设阈值进行比较

local_time=$(date +"%Y%m%d %H:%M:%S") # 获取时间
local_ip=$(ifconfig ens33 | grep netmask | tr -s " " | cut -d" " -f3) # 获取ens33网卡IP
free_mem=$(cat /proc/meminfo | grep Avai | tr -s " " | cut -d" " -f2) # 获取剩余内存大小
free_disk=$(df | grep "\$" | tr -s " " | cut -d" " -f4) # 获取剩余磁盘大小
cpu_load=$(cat /proc/loadavg | cut -d" " -f3) # 获取工作负载
login_user=$(who | wc -l) # 获取登录系统用户
procs=$(ps aux | wc -l) # 获取当前进程数

# 当剩余内存不足1GB时发送邮件给root进行报警
[ $free_mem -lt 1048576 ] && echo "$local_time 可用内存不足，可用内存：$free_mem 在 $local_ip 机器" | mail -s 警告 root@localhost

# 当剩余磁盘不足10GB时发送邮件给root进行报警
[ $free_disk -lt 10485760 ] && echo "$local_time 可用磁盘不足，可用内存：$free_disk 在 $local_ip 机器" | mail -s 警告 root@localhost

# 当剩CPU 15min 平均负载超过4时发送邮件给root进行报警，因为包含小数所以使用bc
result=$(echo "$cpu_load > 4" | bc)
[ $result -eq 1 ] && echo "$local_time CPU负载过高，CPU负载：$cpu_load 在 $local_ip 机器" | mail -s 警告 root@localhost

# 当剩实时在线人数大于3人时发送邮件给root进行报警
[ $login_user -gt 3 ] && echo "$local_time 登录用户过多，$login_user 登录在 $local_ip 机器" | mail -s 警告 root@localhost

# 当剩实时进程数大于50时发送邮件给root进行报警
[ $procs -gt 50 ] && echo "$local_time 进行执行过多，$procs 执行在 $local_ip 机器" | mail -s 警告 root@localhost
```
